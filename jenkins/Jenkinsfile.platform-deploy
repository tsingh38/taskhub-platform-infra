pipeline {
  agent any

  options {
    disableConcurrentBuilds()
    timestamps()
  }

  parameters {
    booleanParam(
      name: 'CONFIRM_APPLY',
      defaultValue: false,
      description: 'Safety switch: must be TRUE to run Terraform apply.'
    )
    booleanParam(
      name: 'CONFIRM_PROD',
      defaultValue: false,
      description: 'Required when TARGET=prod'
    )
    choice(
      name: 'TARGET',
      choices: ['monitoring', 'dev', 'prod'],
      description: 'Which platform stack to apply'
    )
  }

  environment {
    KUBECONFIG = "/var/lib/jenkins/.kube/config"

    TF_STATE_MONITORING = "/var/lib/jenkins/terraform-state/taskhub-monitoring/terraform.tfstate"
    TF_STATE_DEV        = "/var/lib/jenkins/terraform-state/taskhub-dev/terraform.tfstate"
    TF_STATE_PROD       = "/var/lib/jenkins/terraform-state/taskhub-prod/terraform.tfstate"
  }

  stages {

    stage('Validate') {
      steps {
        script {
          if (!params.CONFIRM_APPLY) {
            error("Apply blocked. Tick CONFIRM_APPLY=true.")
          }
          if (params.TARGET == 'prod' && !params.CONFIRM_PROD) {
            error("Blocked: set CONFIRM_PROD=true to apply PROD.")
          }
          echo "Platform apply TARGET=${params.TARGET}"
        }
        sh '''
          set -eu
          export KUBECONFIG="$KUBECONFIG"
          test -f "$KUBECONFIG"
        '''
      }
    }

    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Precheck: Prometheus CRDs') {
      when { expression { return params.TARGET == 'dev' || params.TARGET == 'prod' } }
      steps {
        sh '''
          set -eu
          export KUBECONFIG="$KUBECONFIG"
          echo "Checking ServiceMonitor CRD exists..."
          kubectl get crd servicemonitors.monitoring.coreos.com >/dev/null 2>&1 || {
            echo "ERROR: ServiceMonitor CRD not found."
            echo "Run platform deploy with TARGET=monitoring first (installs Prometheus Operator / CRDs)."
            exit 1
          }
          echo "OK: ServiceMonitor CRD exists."
        '''
      }
    }

    stage('Terraform Apply (Monitoring)') {
      when { expression { return params.TARGET == 'monitoring' } }
      steps {
        dir('infra/terraform/monitoring') {
          withCredentials([string(credentialsId: 'slack-webhook-url', variable: 'SLACK_WEBHOOK')]) {
            sh '''
              set -eu
              export KUBECONFIG="$KUBECONFIG"
              mkdir -p "$(dirname "$TF_STATE_MONITORING")"

              export TF_VAR_kubeconfig_path="$KUBECONFIG"
              export TF_VAR_slack_webhook_url="$SLACK_WEBHOOK"

              terraform init -reconfigure -input=false -backend-config="path=$TF_STATE_MONITORING"
              terraform apply -auto-approve -input=false
            '''
          }
        }
      }
    }

    stage('Terraform Apply (DEV)') {
      when { expression { return params.TARGET == 'dev' } }
      steps {
        dir('infra/terraform/dev') {
          withCredentials([
            string(credentialsId: 'db-user', variable: 'DB_USER_DEV'),
            string(credentialsId: 'db-password', variable: 'DB_PASSWORD_DEV')
          ]) {
            sh '''
              set -eu
              export KUBECONFIG="$KUBECONFIG"
              mkdir -p "$(dirname "$TF_STATE_DEV")"

              export TF_VAR_kubeconfig_path="$KUBECONFIG"
              export TF_VAR_db_user_dev="$DB_USER_DEV"
              export TF_VAR_db_password_dev="$DB_PASSWORD_DEV"

              terraform init -reconfigure -input=false -backend-config="path=$TF_STATE_DEV"
              terraform apply -auto-approve -input=false
            '''
          }
        }
      }
    }

    stage('Terraform Apply (PROD)') {
      when { expression { return params.TARGET == 'prod' } }
      steps {
        dir('infra/terraform/prod') {
          withCredentials([
            string(credentialsId: 'db-user-prod', variable: 'DB_USER_PROD'),
            string(credentialsId: 'db-password-prod', variable: 'DB_PASSWORD_PROD')
          ]) {
            sh '''
              set -eu
              export KUBECONFIG="$KUBECONFIG"
              mkdir -p "$(dirname "$TF_STATE_PROD")"

              export TF_VAR_kubeconfig_path="$KUBECONFIG"
              export TF_VAR_db_user_prod="$DB_USER_PROD"
              export TF_VAR_db_password_prod="$DB_PASSWORD_PROD"

              terraform init -reconfigure -input=false -backend-config="path=$TF_STATE_PROD"
              terraform apply -auto-approve -input=false
            '''
          }
        }
      }
    }

    stage('Post-Apply Checks') {
      steps {
        sh '''
          set -eu
          export KUBECONFIG="$KUBECONFIG"

          echo "Namespaces:"
          kubectl get ns | egrep 'dev|prod|monitoring' || true
          echo ""
          echo "Monitoring:"
          kubectl -n monitoring get pods -o wide || true
          echo ""
          echo "DEV:"
          kubectl -n dev get pods -o wide || true
          echo ""
          echo "PROD:"
          kubectl -n prod get pods -o wide || true
        '''
      }
    }
  }

  post {
    success { echo "Platform apply SUCCESS (TARGET=${params.TARGET})" }
    failure { echo "Platform apply FAILED (TARGET=${params.TARGET})" }
  }
}