// jenkins/Jenkinsfile.deploy-dev
pipeline {
  agent any

  options {
    disableConcurrentBuilds()
    timestamps()
  }

  parameters {
    string(
      name: 'IMAGE_TAG',
      defaultValue: 'KEEP_CURRENT',
      description: 'Docker image tag to deploy to DEV. Use KEEP_CURRENT to reuse the currently deployed tag and only apply values changes (e.g., replicas).'
    )
  }

  environment {
    KUBECONFIG = "/var/lib/jenkins/.kube/config"

    // DEV target
    NAMESPACE  = "dev"
    RELEASE    = "task-service"
    IMAGE_REPO = "tsingh38/taskhub"

    // Repo paths (taskhub-platform-infra)
    CHART_DIR  = "infra/helm/charts/task-service"
    VALUES_DEV = "infra/helm/values/task-service/values-dev.yaml"
  }

  stages {

    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Validate') {
      steps {
        script {
          if (!params.IMAGE_TAG?.trim()) {
            error("IMAGE_TAG is required. Use KEEP_CURRENT to reuse the currently deployed tag.")
          }
        }

        sh '''#!/bin/bash
          set -euo pipefail
          test -f "$KUBECONFIG"
          test -d "$CHART_DIR"
          test -f "$VALUES_DEV"
          echo "OK: KUBECONFIG + chart + values present"
        '''
      }
    }

stage('Resolve Effective Tag') {
  steps {
    script {
      def requested = (params.IMAGE_TAG ?: '').trim()

      // Treat empty the same as KEEP_CURRENT
      if (requested && requested != "KEEP_CURRENT") {
        env.EFFECTIVE_TAG = requested
        echo "EFFECTIVE_TAG=${env.EFFECTIVE_TAG} (from parameter)"
        return
      }

      // KEEP_CURRENT (or empty) -> resolve from cluster
      def tag = sh(
        script: """#!/bin/bash
          set -euo pipefail
          export KUBECONFIG="${env.KUBECONFIG}"

          # 1) Prefer Helm values
          t=\$(helm -n "${env.NAMESPACE}" get values "${env.RELEASE}" -o yaml 2>/dev/null | awk '/^[[:space:]]*tag:/{print \$2; exit}' | tr -d '"')
          if [ -n "\${t}" ] && [ "\${t}" != "null" ]; then
            echo "\${t}"
            exit 0
          fi

          # 2) Fallback: parse live Deployment image
          t=\$(kubectl -n "${env.NAMESPACE}" get deploy "${env.RELEASE}" -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null | awk -F: '{print \$NF}')
          if [ -n "\${t}" ] && [ "\${t}" != "null" ]; then
            echo "\${t}"
            exit 0
          fi

          exit 1
        """,
        returnStdout: true
      ).trim()

      if (!tag) {
        error("KEEP_CURRENT requested, but could not resolve current image tag from Helm values or Deployment.")
      }

      env.EFFECTIVE_TAG = tag
      echo "EFFECTIVE_TAG=${env.EFFECTIVE_TAG} (resolved from running release)"
    }
  }
}

    stage('Helm Upgrade DEV (task-service)') {
      steps {
        dir("${env.CHART_DIR}") {
          sh """#!/bin/bash
            set -euo pipefail
            export KUBECONFIG="${env.KUBECONFIG}"

            echo "Deploying DEV: ns=${env.NAMESPACE}, release=${env.RELEASE}, tag=${env.EFFECTIVE_TAG}"

            helm upgrade --install "${env.RELEASE}" . \\
              -n "${env.NAMESPACE}" --create-namespace \\
              -f "${env.WORKSPACE}/${env.VALUES_DEV}" \\
              --set image.repository="${env.IMAGE_REPO}" \\
              --set image.tag="${env.EFFECTIVE_TAG}" \\
              --wait --timeout 7m --atomic
          """
        }
      }
    }

    stage('Post-Deploy Checks') {
      steps {
        sh """#!/bin/bash
          set -euo pipefail
          export KUBECONFIG="${env.KUBECONFIG}"

          echo "Helm status:"
          helm -n "${env.NAMESPACE}" status "${env.RELEASE}" | sed -n '1,80p' || true
          echo ""
          echo "Deployment:"
          kubectl -n "${env.NAMESPACE}" get deploy "${env.RELEASE}" -o wide || true
          echo ""
          echo "Pods:"
          kubectl -n "${env.NAMESPACE}" get pods -o wide || true
        """
      }
    }
  }

  post {
    success { echo "DEV Deploy Success (EFFECTIVE_TAG=${env.EFFECTIVE_TAG})" }
    failure { echo "DEV Deploy Failed" }
  }
}